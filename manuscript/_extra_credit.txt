
-# A Simple App - Extra Credit

As far as we're concerned, the job is done for the requirements given at the start. This was never intended to be a fully complete application, and a lot of functionality was always intended to be removed to simplify things. Nevertheless, we can take things a few more steps towards completion, and learn some handy stuff.

Of particular interest are a few bits of refactoring. We can add some persistence, meaning that we save our data. Typically this is to an API of some kind, but it doesn't have to be, and in this case it won't be. The other thing we're wanting to do is to implement components. Finally, we'll put in place some animations to smooth our interface.

# Using Components

Most JavaScript frameworks are based nearly completely on components. Their routers essentially choose which "parent component" to use. The component in those cases is the sort of first order object, the base building block. In Ember they're secondary, with the Route object forming the central object type for the application's structure. That being said, components **are** hugely important for Ember, and it's absolutely best-practice to use them liberally.

Our routes and templates for todo items are a bit messy. Let's be honest, no one is going to use a todo list like this. They're going to want editing to be in-place. They're not going to ever want to go to the "page" for an item. And we have todo-related stuff scattered through several routes. It would be nice to be able to move that stuff out and make it all neater. Components allow us to do that, making self-contained elements. Components can be as small as a button, or as large as a whole form or page.

This section may get slightly complicated. This is because we're "double handling" so much functionality, having made the route-based application and then refactored. Had we started off with this better component structure, things would seem much smoother.

Components are something I struggled to "get" for a long time. The best way to think of them is as a custom HTML element. There is a lot of behaviour in a HTML element such as a text input. It needs to support placeholders, that are grey and vanish if your type something else. They need to support things like max size, rejecting invalid input, handle options such as pattern. The browser does all this without your help. But they're necessarily generic. Components let you make html-like-elements that are specific to your application.

T> For the record, you've actually already used components. The Link-to helper is actually a component for dealing with links, and the Font Awesome add-on gives us the `{{fa-icon}}` component.

Components can exist in two forms, block and inline. A block component is denoted by a hash, and wraps content. As just mentioned, the link-to helper is a component, and it actually has an inline form as well, in this form it takes the link text as its second (not third) argument, with the actual route as third. `{{link-to "About Us" "about"}}`

## Creating a component

Ember Components **must** be written to a specific naming convention, including a hyphen. So `todo` is not a valid component name, but `todo-item` is. This is mostly it's so that it's consistent with the upcoming Custom Elements spec. Once that is implemented, standardized and supported, Ember's own components can begin to be phased out.

We can go ahead and make a component the expected way: `ember g component todo-form`.

That will make two main files. It will create the `app/components/todo-form.js` and `app/templates/components/todo-form.hbs`. The hbs file is obviously the template, while the js file contains primarily any actions and properties of the component.

T> As with route and many other elements, generated files can be created with the `--pod` flag to change the structure, in this case to `app/components/todo-form/component.js` and `app/components/todo-form/template.hbs`. I much prefer this format, personally.

## Component templates

Let's start playing around with the template first. The first thing you're going to see (because it's the only thing here) is the `{{yield}}` helper. In the case of block components, `{{yield}}` will display the content placed between the blocks. Our component won't have a block usage, though, so feel free to delete that.

We're going to be replacing out the list item that contains the todo, so grab the contents of the list item in `app/templates/todo.hbs` and paste it right into our component template at `app/components/todo-item.hbs`. You don't need the actual li tag, just its contents, we'll deal with the li tag later.

W> Make sure you delete the `{{if item.checked "...` section of the `li` tag as well. Note that there's a trailing `">`` on the end of that. We'll have to recreate this functionality slightly differently.

## Embedding the component

Using your new component is easy. Insert it as `{{todo-form}}`. The point of a component is that it shouldn't "know" anything. Like a HTML element, it has few real properties of its own, and all of its knowledge needs to be passed in when you use it. If you think about an `<input>`, it needs to be passed type, name, value, placeholder, etc. There are quite a few options we want on this one, so let's start passing stuff in. For a start, we need the actual item in there, from the model. So any sort of state or setting or data needs to be passed through, in this case `item=item`.

T> Note that this isn't considered best-practice. Just as you wouldn't pass the entire user to a text input, you would pass just the actual name, for good components you should be doing the same. In this case, for example, a todo-item becomes highly specific. It will only work with items, nothing else. We're ok with this, but it deserves to be mentioned.

## Replacing the list items

Each component makes itself an HTML element when its embedded. By default it will be a div, but that's not what we want. What we actually want each element to be is the `li` that made up the item previously, and we can do that using the tagName attribute to set it as an `li`, and we will also set the class to what we actually had for bootstrap to style it. The total component embedding should be this in the each loop for `todos.hbs`.

```
<ul class="list-group">
{{#each model as |item|}}
  {{todo-item item=item tagName="li" class="list-group-item"}}
{{/each}
</ul>
```

T> Future versions of Ember will support angle bracket components, like `<todo-form>`, sticking even closer to the Custom Elements spec.

If you go back to the browser you'll see that the interface still **looks** largely right, but we've broken it a bit. In particular, the edit link is still a link. We don't really want to go to that. We're going to want there wo be two different "states" for the item, normal, and edit mode. We'll do that by creating a simple boolean property on the component JavaScript at `app/components/todo-form.js`.

```
export default Ember.Component.extend({
  isEditing: false
});
```

Go back into the component's template and we can modify the content to add an if condition. Grab the HTML from the `app/todo/edit.hbs` template and paste it into the `if` block, while the list item content stays in the else.

```
{{#if isEditing}}
  <!-- edit form goes here -->
  <!-- formerly in app/templates/todo/edit.hbs -->
{{else}}
  <!-- list item content goes here -->
  <!-- formerly in app/templates/todos.hbs -->
{{/if}}
```

Again, that should still **look** about right, because the default view is the show view anyway, not the editing view. If you change the `isEditing` property manually in the JavaScript file you'll see that the edit form comes up. What we need to be able to do is change that from clicking the edit icon. You'll see the item in question in the bottom of our component template. You currently have a link-to wrapping it, but that's not what we want. We just want to put an action on it. We want to tell it to do something when we click on it.

There are a couple of ways we can handle this, but we'll do it by putting an action call on the div that wraps the icon. So in that all we need to do is write `{{action "enableEditing"}}` and the icon will now function as an action.

```
<div class="pull-right edit-link" {{action "enableEditing"}}>
  {{fa-icon "pencil"}}
</div>
```

We'll need to make that action, and we can do so directly in the component JS. All it needs to do is set `isEditing` to true. While we're there, it makes sense to make a second one that simply does the opposite. We're going to need that sooner rather than later.

```
export default Ember.Component.extend({
  isEditing: false,
  actions: {
    enableEditing(){
      this.set('isEditing', true);
    },
    disableEditing(){
      this.set('isEditing', false);
    }
  }
});
```

T> It may seem more logical to say `this.isEditing = true;` but Ember need to make sure all of the watchers can watch, and everything stays in sync. Additionally we could make a generic toggleEditing method that swaps the value back and forth, but being explicit here is a little easier to follow, and makes our code a little easier to write.

Clicking on our edit button should now give us a form, and the addition of a cancel button or X with the disableEditing action will let us return to our default.

## Handling the save functionality

Up to now, the switch to components hasn't been particularly significant. Because template code is **in** the component, it's largely unaffected. Where it does matter more is how actions and events work. Components are a more isolated approach, and while actions in our previous application structure bubble automatically, in components we need to handle that bubbling ourselves, calling the parent's actions. In the case of a deeply nested component structure (both common and recommended), that means some very fragile bubbling through potentially multiple layers of code.

Thankfully there **is** a better way. We will start off by creating a controller. The choice to put all the actions on the Route was totally valid previously. It was a very "routy" application, and our subroutes wanted access to the parent model, etc. That sort of thing is much easier in routes. But here we want more control over our action handling. Actions in components are most easily run "in context", that context in this case being the controller.

```
ember g controller todo
```

We still need to handle the actual update function, but that's easy, just move the entire actions object over from the `app/routes/todo/edit.js` into `app/controllers/todo.js` controller and it should be fine. In fact you can delete that edit route once you nab its action. We also need to make sure we remove the entry from the router.

We're consolidating down a lot of flexibility here, which should really clean up our code. The `app/controllers/todo.js` file will contain nearly all of our actions and functionality, while the components themselves handle their own state. This means very shortly we can delete everything in our `app/templates/todo` and `app/routes/todo` folders, as well as removing the routes from the router.

First, though, we need to make some template changes. For a start, the `model` we were using was coming through from the route. We no longer have that, we have the `item`. We could have actually passed in `model=item` and not changed our code, but it's a bit misleading, because it's not really a model.

We need to go through and find the places we've used model, in both the form and list item display. This should be the complete template, with a few minor changes for readabiliy.

```
{{#if isEditing}}
<div class="form-group">
  <label for="text">Text</label>
  {{input value=item.text class="form-control"}}
</div>
<div class="form-group">
  <button class="btn btn-info"{{action "saveItem" item}}>
    {{fa-icon "cloud-upload"}} Save
  </button>
  <span class="pull-right"{{action 'disableEditing'}}>
    {{fa-icon 'times'}}
  </span>
</div>
{{else}}
<span class="check-icon" {{action 'checkItem' item}}>
  {{fa-icon (if item.checked "check-square-o" "square-o")}}
</span>
<span class="item-text">{{item.text}}</span>
<span {{action 'enableEditing'}}>
  {{fa-icon "pencil" class="pull-right edit-link"}}
</span>
{{/if}}
```

We've also removed the link to the `show` route, as it doesn't make a lot of sense anymore, so we can completely remove that `show` route and template as well. We can also copy over the route actions from `apps/routes/todo.js` and `apps/routes/todo/new.js`, and put them into the controller actions. We'll link them up soon.

Our functionality still doesn't work. If we save the the item we get an error. Our controller has the action, but our component doesn't have anything to handle it. We talked a little earlier about the "context" being the controller and the template together.

The issue here is that the component creates its own context. It's triggering the saveItem action **inside the component**, but that doesn't exist, so it blocks the passage of the action. Our component's todo-form JavaScript still needs to handle the action, even if that is just to pass the action through to the controller. Components by their nature need to be passed in anything they need access to, but they also need to pass any action or event back out. So we can actually pass in an action function directly to the component, and then tell it to execute it. It needs to be restated that we're literally passing in the function itself here as a closure.

```
{{todo-item item=item tagName="li" class="list-group-item"
  saveAction=(action "updateItem")}}
```

We also need to add another simple action in our component `todo-form.js`, alongside enable and disable of editing. The code is this.

```
  saveItem(item) {
    this.set('isEditing', false);
    this.attrs.saveAction(item);
  }
```

There's a lot to this despite the simplicity. None of it is anywhere nearly as complex as I thought, and as a result I struggled to understand this for some time. I thought there was a lot more *magic* involved than there actually is. For a start, we set the `isEditing` flag to false again to close the form. That bit is fairly obvious.

There are two key things that I think are needed to make it more clear what's happening here. First of all, it's important to really understand what the `action` helper is doing. The action helper simply creates a function from a given string. That string is the name of an action in a given context - in this case the controller. The action helper wraps up that context and creates a function, so that concepts like `this.get` still have meaning. Because it does this, the action helper creates a function that is completely portable and can be passed around and executed from anywhere. This context (and thus this function) are created in the template, when we pass in that action as the `saveAction`.

The second thing to understand is that all of the `saveItem` and `updateItem` functions are different and are not really connected. There's no inherent magic binding happening here. When we click the action on the "Update" button, it simply executes the component's saveItem action. In that function we are explicitly calling another function. In components, `this.attrs` is the attributes passed in when creating the component, specifically it includes the actions.

In this case, the `saveAction` attribute is a function, and as such it can be directly executed as `this.attrs.saveAction(item)` passing straight through the closure given in by the component action call.

T> We're inventing these names, and there's not necessarily any reason to call it `saveAction`, but otherwise we end up with `saveItem=(action "saveItem")` which calls the `saveItem` function which executes `this.attrs.saveItem`, and it gets pretty unclear what comes from where.

One you fully **get** this it's surprisingly simple and powerful, as we'll see from our next example.

## Creating a new item - component

It might seem like the obvious solution is to make another component to form the "new" interface. But in truth, we already have the component we need. We can just re-use the `todo-form` component.

Again, we've got some actions in a route that we want to have in the controller, in particular, `createItem`. Unfortunately, the action here is going to need quite a bit of refactoring, but as looks are far more important than functionality, we'll deal with the template first.

Because we're just reusing our editing component we end up with an `isEditing` property. That's not the most ideal terminology, but it's clear what it means, so we'll just use it as-is.

## New item component - action and template.

We already have all of the enable and disable editing functionality in our component. We only need to make one change. In its "default" state, with editing off, our normal todo-form components display a list-item with an edit pencil, and the task. This obviously doesn't apply to the new item. We want a button, but **then** the same form. This means we need a little bit of logic in our template, and to pass in a new attribute to our component.

```
{{todo-form isNew=true ... }}
```

We now need to make the template use this property to determine whether to show the button or the todo item. You don't need to pass in `isNew=false` to your list items, it's fine without them. Our completed component template should look something like this.

```
{{#if isEditing}}
<div class="form-group">
  <label for="text">Text</label>
  {{input value=item.text class="form-control edit-field"}}
</div>
<div class="form-group">
  <button class="btn btn-info"{{action "saveItem" item}}>
    {{fa-icon "cloud-upload"}} Save
  </button>
  <span class="pull-right"{{action 'disableEditing'}}>
    {{fa-icon 'times'}}
  </span>
</div>
{{else}}
  {{#if isNew}}
    <button class="btn btn-info" {{action 'enableEditing'}}>
      {{fa-icon "plus-circle"}} Add New
    </button>
    {{fa-icon "times" action=(action "disableEditing")
      class="pull-right cancel-edit"}}
  {{else}}
    <span class="check-icon" {{action 'checkItem' item}}>
    {{fa-icon
      (if item.checked "check-square-o" "square-o")
      fixedWidth=true
    }}
    </span>
    <span class="item-text {{if item.checked 'checked'}}">
      {{item.text}}
    </span>
    <span {{action 'enableEditing'}} class="pull-right edit-link">
      {{fa-icon "pencil"}}
    </span>
  {{/if}}
{{/if}}
```

This code has evolved over time, and gotten quite complicated. That's OK, because it's doing quite a lot of things. In particular, we've got a lot of functionality glommed into the actual icons now. Of particular note is the `fa-icon` for the checkbox, which has a lot of properties set, including an inline "if" to dynamically determine what icon to display, the action required, and a fixedWidth option. The fixedWidth setting here just makes the icon a pre-defined size. The checked and unchecked versions are a slightly different size otherwise, and shift around.

We could do something similar with our pencil icon, putting actions and class on the icon. It could have the same pattern as the checkbox in that respect. Either option is valid. Using both together probably isn't ideal.

T> You'll note a suprising amount of this interface is just turning things on and off. We're trying to keep things nice and explicit here, however there would be an opportunity for a refactor here. Look into the `mut` helper if you're curious. By using something like `{{action (mut isEditing) true}}` you can actually eliminate the `enableEditing` method and its partner altogether, setting the values directly through interactions with the template.

The implementation of the template is pretty simple, with this block now in `app/templates/todo.hbs`.

```
<ul class="list-group">
{{#each model as |item|}}
  {{todo-form item=item tagName="li"
    class="list-group-item"
    saveAction=(action "updateItem")
  }}
{{/each}
{{todo-form isNew=true tagName="li" class="list-group-item"
  saveAction=(action "createItem")
}}
</ul>
```

The change noted here is that we're passing in a different action as saveAction. This means when `this.attrs.saveAction(item)` is executed it will do different things, while using the exact same code structure. The component can do completely different things, without ever having to have a dependency on how or what it saves. The other point that might be easily missed is that we no longer pass in `item=item` in our new item component. There's no reasonable thing to call "item" in this case. And as we're not using a route, we can't create an empty object either. However, if we don't have an item, Ember has nothing to perform its edits on.

The solution is surprisingly simple, just add an `item: {}` property to the component JS. The passed in element will override it if need be, but new items have a blank object to serve as a default.

Adding to the empty field should now work, but we need to return to the `createItem` action, because it's fatally flawed for a controller.

Where controllers and routes largely differ is what they have access to and how. The `this.modelFor` methods are intended for routes to access data from other routes. The controller has a simpler call to get its own model, `this.get('model')`. Much of the rest is the same, but as we're no longer transitioning, we can cut that line out, and make the object directly in the collection.

We can also update the `checkItem` function, which is very simple. The simplest update is to just delete it. There's no difference between a `checkItem` action and just changing a value and running the save action. We can handle that in the component directly.

The `app/controllers/todo.js` file should now contain a moderate amount of quite clear code, consisting of a few actions. It should look more or less like this.

```
export default Ember.Controller.extend({
  actions: {
    updateItem(item){
      console.log('item updated');
    },
    createItem(item){
      this.get('model').pushObject({
        text: item.text,
        checked: false
      });
      console.log('item created');
    }
  }
});
```

In this case, we end up with our complete component `todo-form.js` file looking like this.

```
export default Ember.Component.extend({
  isEditing: false,
  item: {},
  actions: {
    enableEditing(){
      this.set('isEditing', true);
    },
    disableEditing(){
      this.set('isEditing', false);
    },
    saveItem(item){
      this.set('isEditing', false);
      // optional: if making a new item,
      // blank out the form after saving
      if(this.get('isNew')) {
        this.set('item', {});
      }
      this.attrs.saveAction(item);
    },
    checkItem(item){
      Ember.set(item, 'checked', !Ember.get(item, 'checked'));
      this.attrs.saveItem(item);
    }
  }
});
```

You'll notice that all of the code in the `routes/todo/new.js` file isn't particularly relevant. That's not a route anyone can or will go to now. You can happily delete it. In fact you can delete that whole `app/routes/todo/` directory, as well as the `app/templates/todo/` directory. Don't forget to delete the auto-generated unit tests! Note that you can actually run `ember destroy route todo/edit`, etc, and it will do all of this for you, including deleting no-longer-needed route, clearing the unnecessary tests, and stripping them  out of the router. It should go without saying that this command should be used carefully. If you delete manually, make sure you remove the router entries.

We've been able to remove a substantial amount of code, simplifying our interface substantially. We now have dedicated components for specific behaviours, and most importantly a better, and more useable system.

## Fixing our tests

If you go back and run `ember test` you'll notice that it now fails.

There are a number of failing tests. The first is a component integration test at `tests/integration/components/todo-form-test.js`, which determines that the component properly outputs when used in block syntax. Ours does not, nor should it. `{{#todo-item}}{{/todo-item}}` isn't something this supports. We can just delete that test.

There is a fair chance that route tests are also still broken, from `todo/new.js`, and so on. Make sure those are cleared out where applicable.

We've made some drastic changes, and we **should** have changed the tests first, then updated the code. If you go back to our new item test at `tests/acceptance-tests/todo-new-test.js`, the behaviour here has changed. For the most part it's the same. Items are still created and still added to the list, the last item should still have the given text. But that final `assert.equal` no longer has any relevance. We don't have that route to link to any more. So just remove that line.

```
test('Creating new item', function(assert) {
  const itemText = 'Some random text';
  const expectedLength = 5;

  visit('/todo');
  click('#new-item-button');
  fillIn('.edit-field', itemText);
  click('button.save-button');

  andThen(function() {
    let itemList = find('.list-group-item .item-text');
    let itemListLength = itemList.length;
    let lastItemText = itemList.last().text().trim();

    assert.equal(expectedLength, itemListLength);
    assert.equal(itemText, lastItemText);
  });
});
```

You may notice that we've changed the selectors used on our `click`, `fillIn` and later test selection interactions. These are necessary because we've changed the structure slightly, enough that our previous tests were invalidated. The new item button didn't change, but we don't want too many ids in the component, as things like "create-button" won't often be correct. We've used more generic and meaningful class selectors here. These will also need to be correct in the markup.

The `todo-check-test` also needs similar updates for similar reason. As we're no longer putting the checked class on the `li` element (our component's direct container) we're putting it on the `span.item-text` inside it, so we need to update to `find('li:nth-child(2) .item-text')`.

Finally, our CSS doesn't quite match this either. We can just replace our `li.checked` selector with the strike-through on it with `li.list-group-item span.checked` to recover our previous styling.


# Persisting With Ember Data

The main feature missing from this app is persistence, the ability to save the data back to something. So that's the next thing we'll tackle in these bonus lessons.

## Ember Data models

Persisting data is primarily done in Ember using an add-on called Ember Data. Ember Data looks (and functions) a great deal like Eloquent does in Laravel. That is to say it abstracts the data handling, and provides a way of defining models and the relationships between them to make data access more consistent and simpler.

Ember Data is built into Ember CLI, so you don't need to install it to use it. Like everything else in Ember we can generate an Ember Data model easily. Just run `ember g model todo`, and the model class will be put into the `app/models/` directory. Open that up and you'll see the basic boilerplate for a model.

By itself that won't do much. We need to define a little bit more structure to make it helpful, and that comes down to essentially replicating the structure we had in our model hook in the todo route.

```
export default DS.Model.extend({
  text: DS.attr('string'),
  checked: DS.attr('boolean')
});
```

You may notice id is not in there. Ember Data knows what that is, and handles it internally. Unlike Eloquent, though, you do need to explicitly state the fields. This Ember Data model is also where you would handle any relationships between models, such as a Post model might have `comments: DS.hasMany('comment')`.

The namespace imported here is `DS`, rather than the more typical `Ember`. DS stands for "data store", Ember's in-memory collection of models. This is a service widely available in Ember routes and controllers.

The type here is optional, and often omitted especially for its default of strings. We can also specify a default, and we'll do that on the checked property here, by adding an object with a `defaultValue` key after the boolean. You should end up with `DS.attr('boolean', {defaultValue: false})`. This object with `defaultValue` is also rarely used, but sometimes both are handy to make it clear to both Ember Data and any human reader exactly what is intended. In this case we want our tasks to always be false from the start.

T> If you know in advance what you want in an Ember Data model, you can actually add them in the generation command. `ember g model todo text:string checked:boolean`.

## Adapters

Adapters tell Ember Data what the rules are for reading the model's actual persisted form. Is it a RESTful API? Some sort of SOAP call? A backend-as-a-service like Firebase? An S3 instance? Where does it live, how do we connect?

As much as possible we do **not** want the rest of the app to care about this, we just want to know that when we call `model.find(12)` our model will be sent back from the server. All the rules and implementation details of how to achieve that should live in the adapter.

Adapters sound hard to set up, but they're not. Common standards - such as Rails Active Record or REST - have standard addons that work right up. Other common cases such as Firebase are a single install away. In fact, if you set **no** adapter it uses something very like REST by default, which is the JSON-API spec.

We don't want to use REST though. We don't want to set up a whole API. We want to store this locally, so we want to use the localStorage adapter.

First of all, we need an adapter for the model. Ember can take a different adapter for each model, so your user data could be on a REST API, while some order info lives in Firebase. Totally fine, and relationships between them can still be maintained. Ember Data is one of Ember's real killer features.

We can make an adapter exactly as you would expect by now. You just need to specify what model you want to make an adapter for.

```
ember generate adapter todo
```

T> You can actually create an adapter called "application", which will then be all models unless overriden by a specific one. We could have used application here, but wanted it to be more clear what exactly the model and adaptor are doing and how they relate. Honestly just making an application adapter is more useful most of the time, as it's rare to split the data like that.

Now all we need to do is install the LocalStorage adapter.

```
ember install ember-localstorage-adapter
```

Restart the ember server and you'll have a working model that uses the browser's LocalStorage for persistence. If you go to `app/adapters` (a new directory) and open the `todo.js` file you'll see that it's much like most of the modules your generators build. In this case we have to change a little more than usual. Ember generated a generic "JSONAPIAdapter" adaptor, not a LocalStorage adapter, so we need to update the code to the following

```
import LSAdapter from 'ember-localstorage-adapter';

export default LSAdapter.extend({
  namespace: 'todo-app'
});
```

The namespace option here is just used as a key for local storage, but in a more typical server environment it will be something like `api/v1`. It is also very common to have a `host` option in here, which tells Ember where to connect to the API. That's meaningless in localStorage, but critical in most other connections.

## Serializers

Where the adapter handles how to connect, the serializer handles data, specifically how to read and write it. Most often serializers are simple things, just passing through whatever they're sent, but in cases with complex rules or specific requirements they're the place you want to implement those, converting your `firstName` field to the API's required `FIELD_FIRST_NAME` or whatever.

Serializers are generated the same way as adapters, enough so that I'm not actually going to give the command to do it. The code generated will again need to be updated to make it a LocalStorage serializer rather than the generic default.

```
import { LSSerializer } from 'ember-localstorage-adapter';

export default LSSerializer.extend();
```

We don't actually need to make any changes to this default, we just need Ember to know what serializer to use.

## Using Ember Data in our Todo Route

Using Ember Data models in a route is super easy. All we have to do is replace out the hard-coded contents of the model hook with fancy Ember Data calls. Ember Data collections have some special functions on them to make finding and filtering data easy. The simplest is just to return the whole lot, which is what we actually want anyway.

```
model() {
  return this.get('store').findAll('todo');
}
```

This just finds all the todo items which are valid Ember models. This means it gets data from the server (or in this case, local storage pretending to be a server) and returns that.

## The "store"

The "store" is easily confused, and so deserves some discussion. The store in Ember is its local collection of data. The store can also be used to get data from the server, but they're not synonymous. Data can be in the store but not in the server, and vice versa, or it can be in different states in both. A new item, for example, will be added to the store, but must be saved before its available on the server. Ember has special methods for checking **just** the local collection, typically called `peek`, but we're using its `find` methods here, which will check the server, or more accurately the persistence layer.

Initially no data will be returned, as we haven't made any todo items yet, and we killed our pasted in test items. None of the rest of our code handling these items needs to change. It was always nicely isolated.

T> We don't have our show route for a single todo item any more, but if we did it would have this in its model hook: `return this.store.findRecord('todo', id);`.

## Creating items and saving changes

With no items to edit or display, there's really not a lot here worth seeing. The first thing to do is to update the `app/controllers/todo.js` controller actions in a few places. We need it to do more than just add to the collection, because that's just the stuff Ember is aware of, not the data that's actually on the server.

We'll do that first, and it's only a small code change. We literally just need to replace our `alert` or `console.log` functions with `item.save()`. Running that code will persist the changes to our "server".

The actions we have don't do a lot. All they do is show an alert, which is fine when messing around with test data, but not exactly ideal with persistent data. We need to persist any changes we make. Thankfully that's trivial.

```
export default Ember.Controller.extend({
  actions: {
    updateItem(item){
      item.save();
    },
    createItem(item){
      this.get('store').createRecord('todo', {
        text: item.text,
        checked: false
      }).save();
    },
    checkItem(item){
      item.set('checked', !item.get('checked'));
      item.save();
    }
  }
});
```

You'll probably be noticing at this point how little code is needed here. `item.save()` is a crazy small amount of code to write to persist our data. The only variation is that the `createItem` method doesn't take in a valid model persistable model, but creating a record does, so it's that we save. We're using `store.createRecord` instead of the `pushObject` we had before. The `pushObject` function was for adding entries to any random array array, and the store is quite a different beast. We then save directly afterwards, so the entry is saved to our persistence system. Local storage in this case.

Another nice little convenience refactor we can do is in the `app/components/todo-form.js` where we have a `checkItem` function. That has a fairly long slab of `Ember.set` on it there. Because this is now a proper Ember object rather than a plain JS object, it has its own methods. This means we can simplify it to `item.set` and `item.get`, but even more, we can replace that whole line with a dedicated method for this: `item.toggleProperty('checked');` and then continuing to call the `saveAction`;

It should be noticed that this code would **not change** if we were writing back to a Laravel server, NodeJS or anything else. This code doesn't have to know or care how it's persisted or where. The details of **how** to save are handled in Ember Data, in particular in that localStorage adapter we added in before.

Running `ember test` after those changes isn't a pretty sight. We get a lot of errors. The majority of them are related to the markup structure changes we made, but also, because we're now running a persistence library our assumption that we start with four hard-coded models isn't really correct.

We can fix the new item test most easily. The only change is that instead of a fixed length, there's an assumption that the length is one more than the current. So the expected length line becomes this, while the rest of the test is unchanged.

```
const expectedLength = find('.list-group-item .item-text').length + 1;
```

The check item test is slightly more complicated. Because we are using local storage, and the test process is clearing that automatically, we start each test run with no items. The easiest solution to this is to simply make one, then check it, giving the following test, largely stolen from the new item test.

```
test('Checking a todo item', function(assert) {
  const itemText = 'Some random text';
  visit('/todo');

  click('#new-item-button');
  fillIn('.item-text', itemText);
  click('button.save-button');

  click('.list-group-item:first-child .check-icon');

  andThen(function() {
    let row = find('.list-group-item:first-child .item-text');
    let rowIsChecked = row.hasClass('checked');
    assert.ok(rowIsChecked);
  });
});
```

# Animation

## Liquid Fire and the purpose of animation

Liquid Fire is Ember's semi-official animation add-on. It's most particularly good for animating transitions between routes, or between states of an interface. Used effectively, animations make an interface more engaging and intuitive. Used badly they make it feel slow and clumsy. It's important to have a clear vision for animations, as well as to keep them both consistent and fast.

Speed is critical. You're deliberately interrupting the action the user has requested, and as a result, you're obliged to get the hell out of the way as soon as possible.

Installation is the same as any other add-on in Ember: `ember install liquid-fire`

Unfortunately Liquid Fire lacks some of the ergonomics and polish of other add-ons we've used, but we can work around it. Liquid Fire works in one of two ways. The primary way is by use of a transitions map. This tells Liquid Fire that when it comes to certain specific transitions it should use this particular animation, and in this way. The transition map is not an Ember file, and needs to be made manually at `app/transitions.js`. The contents of that file are as follows. Obviously that doesn't do anything on its own, we just want to stop it breaking EmberCLI.

```
export default function(){
};
```

Transitions are then handled as a series of function calls, essentially `this.transition(/*list of arguments*/)`. The typical format is a `fromRoute`, `toRoute`, and which transition animation to `use`. A `reverse` is also often used, as a shortcut for making the entire thing again, only backwards.

Our simple app only has a few routes, so let's do an example of the transition from about to todo.

```
export default function(){
  this.transition(
    this.fromRoute('about'),
    this.toRoute('todos'),
    this.use('toLeft'),
    this.reverse('toRight')
  );
}
```

It's easy to look at the above code and have in mind that it's declaring a function, like one of our actions or something. But it's important to remember that this is a function **call**, so if you put semi-colons instead of commas you'll be made aware of the syntax issues very quickly. If you look at your application now and click from the `about` to the `index` you'll notice... no change. We're missing a step. We need to change the outlet, from Ember's default to the special Liquid Fire one. If you open `app/templates/application.hbs` you can replace the `{{outlet}}` with `{{liquid-outlet}}` and the animations should kick in.

If you have the console open you might notice here that it gets suddenly chatty. This is the polish mentioned earlier. At time of writing, there was a change to the Ember core that the released version of Liquid Fire hadn't updated to fix yet. This is a deprecation warning, which is how Ember handles code changes. It's not a big issue, just a heads up that you might need to refactor eventually. It doesn't show in published code, just local. In fact, the code **is** fixed newer versions of Liquid Fire and probably won't affect anyone reading this.

We can now do some more transitions, handling all other route transitions, specifically `about` to `index`, and `index` to `todos`. As you can imagine, with a large application this could be an extreme number of transitions, as they grow out exponentially. However, there's a handy shortcut we can take. The `fromRoute` and to `toRoute` are both optional, in that you only need one of them. If not provided they act as a wildcard, meaning **any** transition to or from them triggers a set animation. As a result you can simply set one of them, and greatly simplify the process. Because the home route is always going to be to the left of all other routes, and the todo route is always going to be to the right, our route transitions are covered with this short and clear bit of code:

```
export default function(){

  this.transition(
    this.toRoute('todos'),
    this.use('toLeft'),
    this.reverse('toRight')
  );

  this.transition(
    this.toRoute('index'),
    this.use('toRight'),
    this.reverse('toLeft')
  );

};
```

These transitions may look backwards. We're actually animating how we want the animation to occur, so where the old outlet contents should go. It's easy to assume this is that we want the new item to appear "to the right". Actually, we want the whole section to slide left, bringing the new content in at the right.

Outlet transitions aren't the only place we can benefit from Liquid Fire, nor the only way to use it. We can also use liquid versions of other helpers. Usefully, we can replace our todo-form component `{{if isEditing}}` with a `liquid-if`. In principle we could add this to `transitions.js`, but there's a nicer way. We can add our animation directly onto the the `liquid-if`. The simplest way to do this is to set a "use" attribute. That's the way to ƒset what animation to use in the transition. It's not well documented (if at all) but you can also set a reverse animation. This makes it possible to do something like `{{if isEditing use="toUp" reverse="toDown"}}`. This is a quite effective look, and crossFade works well too. Most interestingly, just leaving a `liquid-if` without any animation at all causes a slight slide effect, which looks better than a standard `if`, which just flicks in and out.

We could also replace the `if` on our checkbox, to make it crossFade or something like that. But in this case it looks better without it. It's mimicking a checkbox, which a user would expect to be instant.

## Conclusion

There's very little else we can do with this app now. It should be working for local persistence, and is animated. There are missing features here, of course. Notably, you can't delete an item. We could keep polishing this site, adding new features. But there isn't a lot of point. We've made a solid effort on an Ember driven app. This is only the start. Ember is at its best when working with very large applications. So for now, it's time to put this app to bed and consider it complete.

There will be a follow up to this, a more advanced and ambitious application that will deal with a great deal more complexity and much more real-world business requirements. We'll implement that using the powerful combination of Laravel and Ember. In the process we'll cover a lot more of authentication, testing, and use some of Ember's more advanced and powerful add-ons.