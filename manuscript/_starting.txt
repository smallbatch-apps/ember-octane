
-# A Simple Application in Ember

# Getting Started With Ember CLI

One of the best features of Ember is Ember CLI. It's a friend, a companion, maybe even a lover.

## Installing Ember and creating a new project

Step one of starting with Ember is to install Ember CLI globally to your system. This assumes NPM is available, of course. On any reasonble and current dev machine it should be. If the `npm` command isn't available you'll need to install the latest **LTS** release of Node. If you use the very latest Node you'll get warnings that EmberCLI isn't tested with this Node version. It works fine, it's just a disclaimer.

```
npm i -g ember-cli
```

![Ember CLI's website gives clear instructions](images/00-embercli.png)

Ember CLI is a pretty solid comparision to Laravel's artisan command line tool in that it has generators and so on, but it packs a lot more punch. Basically if there is stuff you don't want to do - dependency management, setting up task runners, installing addons, etc, Ember CLI will take it off your hands. First among these is scaffolding an entire new application.

```
ember new todo-list
```

This command will create a whole new Ember application, ready to run once NPM gets finished with its admittedly slow business. Change directory into your new directory, and run `ember server`.

Now you have a properly served app at `http://localhost:4200`, configured with live reload, a comprehensive asset management system, build chain, ES6 transpiling, and more. That's Ember's entire build process. You may also notice that the build time takes around 8 - 10 seconds. This only occurs the first time. Subsequent builds occur on saving files and are nearly instant.

This might go without saying, but that terminal window needs to be running to keep serving stuff, so make another one at the same location to input further commands.

T> You should really install the Chrome addon called Ember Inspector. It does a remarkably good job of debugging Ember apps, showing what all the bits are doing, displaying model data, deprecation warnings, etc. All further discussion in this book assumes you have it installed, because you're clearly a smart person who makes good decisions.

If you go to the URL that `ember server` gave you at http://localhost:4200, you'll see Ember's default install app, featuring an adorable hamster. His name is Thomster and he is your friend. We're going to replace this, but not properly or carefully, we'll just wipe over the top of it.

![The Ember Welcome Screen](images/01-welcome-screen.png)

Now would be a pretty good time to make sure whatever editor you use is set up with the new project, or to open the directory, or whatever. Note that while editors often have functionality to make and manage files we shouldn't be needing those. That said, if you have an editor or IDE that has a command line feel free to use that. PHPStorm, Webstorm and Visual Studio Code all definitely do. We'll be using the command line extensively, so having one close will help.

The first step will be editing the application template. The core container of your site is called `application` for reasons that aren't particularly mysterious, and that's a useful term to use for things that apply to the entire thing. It will come up again. We've currently got that base template as a largely empty file, and we'll fix that now. If you go to `apps/templates` in your editor, you'll see it there now - `application.hbs`. You'll see in there some comments saying that you should feel free to delete the contents.

A .hbs file is a handlebars template file. Not too dissimilar to Laravel's Blade. Much like blade, an empty root template with no sections or yields results in a screen a little more Zen than we want. What it needs is an `{{outlet}}`. There's already one here, so just delete the welcome section above and save it. This is functionally similar to Blade's `@yield`. Add a H1 tag above that outlet, and whatever markup you like (I typically put a `<div class="container">` round everything), save, and we'll get on with it. You'll probably notice that Ember rebuilds everything automatically on your file change, and updates the browser accordingly. Wizards. If you can still see your `ember server` tab you will be able to see what it's building, too. That build process even gives you a heads-up about Javascript standard lint errors, which can often be very useful.

![An impressive start](images/02-with-heading.png)

## Generating with EmberCLI

We're going to be doing a lot of this, so it probably makes sense to stop here first and talk about it. Ember's CLI tool can be used to generate the resources Ember needs. There is absolutely nothing wrong with just making the file in your IDE or on the command line, but there are three main benefits with doing it with the CLI.

First of all, it's faster. You don't have to type in the path and file name, so it's nearly always a shorter command than even something like `touch` would be.

Secondly, it's less error prone. There's no chance of misspelling a directory name, or creating an invalid file name that doesn't match Ember's conventions. EmberCLI both relies on and enforces strict file conventions. It's best to let it help.

Finally, the generators typically do much more than just create a file. For example, using EmberCLI to generate a route will create the route file, a template, and unit tests, while also putting boilerplate and stubs ready to go in all three.

Using the generators are extremely easy. The pattern is always the same: `ember generate <type> <name>`. We want to start off by generating a template. We have a base template, but that's for the whole application. We want a template for just the homepage, that will slot into the outlet when people are on the homepage.

```
ember generate template index
```

That will run the command and create a single empty file. It will be at `app/templates/index.hbs`. If you open that and save an `h2` header into it, you'll see it pop in nearly instantly into the interface we have running in the browser. Ember CLI will build new files into your application, typically in around 0.2 of a second. You don't need to refresh your browser.

![Now with index template and header](images/03-index-header.png)

# Routes in Ember

The core thing to know about Ember is that it's all about the routes. Everything is built around the route you use - the actual request string. A *Route* in Ember is a specific object dedicated to handling a given URL pattern.  This simplifies Ember greatly - the current URL is the current state of the app, and can be rebuilt or reloaded or shared without issue. Back and next buttons, sharing and bookmarks all work perfectly fine. Ember manages its own "state" surprisingly well, knowing that different urls should have different state and keeping them distinct automatically so that data and interactions don't leak between them.

That route-centric nature leads to a key difference between Laravel and Ember. The "route" is central to Ember in a way that has no comparison with Laravel.

There are some basic jobs that any sort of MVC framework has to do.

1. Accept the string of the path
2. Find the code that's intended to execute when the path is hit
3. Get the model data that will be needed
4. Get the template used
5. Set up the template to use the data
6. Serve on toast

Ember and Laravel divide these jobs differently. In a Laravel app the Router pretty much handles all of the above. More typically, 1 & 2 are handled in the router. That will also define a controller. In the controller you get the data and template explicitly - items 3 and 4. Variables are injected directly into the template in the controller as well. Returning from the controller triggers the render.

In the case of Ember, the Router handles 1, the Route (note the distinction) handles 2 & 3, while 4 is handled by Ember's conventions which dictate the template's location. From then on things are quite different. Ember's lifecycle is critically different from Laravel's set-and-forget. Everything has to stay live. Ember therefore needs to set up a "context", an environment where a template's values can be routinely set and modified. In principle this means binding a controller to handle the interactions with a template. In practice the controller is often not needed. However, one of the core things a controller does is to handle actions that are occurring on the page. The more a particular view does the more likely a controller is to be needed and useful.

The role of a Route, therefore, is critical in Ember. It sets up everything that comes after. It gets model data, finds the template, and sets up the controller. It's always going to be our first step when adding new features or functionality. In this app we're going to be handling almost all of our code in Routes, and not using a controller at all. There are some complex reasons for this but it shouldn't be taken as any suggestion that there's anything wrong with controllers. They are recommended in a lot of places. The "extra credits" section will refactor some of this code, and **will** actually use a controller as well.

W> If you do a lot of reading you'll quickly learn that Controllers in Ember are deprecated, dead, unnecessary, broken, being replaced or are made of lava. It's true that a lot of the common use of Controllers is better put elsewhere now, but there is absolutely no intention of making controllers go away. Components take up a lot of their code, but they still have significant value, **especially** in a component-heavy app.

## Building our first route

We're going to start off with a basic route. We want an about-us page, because it's apparently mandatory and it gives us a nice static page. The process of this is trivially simple, thanks to the CLI.

```
ember generate route about-us
```

You'll see that run through a few lines of output, generating the files we need. If you open `app/router.js` you'll also see that the router has been updated to add this new route. We don't actually need to edit this manually in these lessons, but doing so is quite common for fine-tuning. We're just looking out of interest. The main files that have been added are a pair - the template and the route.

T> You don't actually have to type `generate`, just typing `ember g` will do the same thing with less tapping. We were trying to be explicit, but from now on `ember g` will be used.

If you edit the new `apps/templates/about-us.hbs` you'll see that it's mostly just a blank file with an `{{output}}` entry. Throw a `<h2>About Us</h2>` at the top. Feel free to put in some lorem ipsum text so you can feel like a real designer, and we'll get on with it. You should also make sure you delete the `{{outlet}}`. We're not going to be putting any sub-routes in here or anything. It won't break anything if you leave it there.

Going to that route at `http://localhost:4200/about-us` will show us exactly what we would expect to see.

![The "about us" page with some text](images/04-about-us.png)

A look at `apps/routes/about-us.js` shows us some pretty standard Ember ES6 boilerplate. More complex routes can have things like the model, actions, various lifecycle hooks and properties set in here, but our route is static HTML, so we don't really need any of that. In fact... delete it. Not the content. The whole `about-us.js` file. Seriously, do it. If you take another look at the page, you'll see that nothing's changed. Apparently routes aren't so important after all!

What's happening here is one of the great strengths of Ember. It has a strong philosophy of "Convention over Configuration". A lot of people take that to mean that Ember follows a strict set of rules. But a better view is to think of it as mutual trust. If Ember's conventions are followed, it behaves with logical and reasonable defaults. In this case, a route is needed, and in fact it's so much needed that if not found, Ember will build one itself, identical to the default one from the generator. This is a **very good thing**, and it means you can simply remove files that don't do anything.

# Starting with Models

## A more useful route

Very few routes are going to be that static. If you're using the SPA pattern to build entirely static content you need to have a good long think about what you're doing with your life. We're going to now use the same process to build a second route.

```
ember g route todo
```

## Adding a model

This route is going to list all the todo items, so it's going to be much less static, and will need actual data. Providing that data is a core responsibility of the Route. This just means adding a model hook to the existing boilerplate for your todo route.

```~
// app/todo/route.js
export default Ember.Route.extend({
  model(){
    return [
      {id: 1, checked: false, text: 'Buy milk'},
      {id: 2, checked: false, text: 'Buy bread'},
      {id: 3, checked: false, text: 'Bring back Firefly'},
      {id: 4, checked: false, text: 'Conquer planet'}
    ];
  }
});
```~

W> Note that the code used in Ember objects always starts with a line of `import Ember from 'ember';`. We're not showing that in these examples, but it will be part of the code generated. It is not shown in these examples **purely to save space** and is definitely required for the code to function. Don't copy out this code and entirely replace the file. Bad things will happen.

This data is now part of the route, and accessible in its templates as the value `model`. This is obviously a simplified example. You would rarely hardcode data like this. A more common approach would be to use Ember Data models, which is kind of like the equivalent of an Eloquent model, forming an ORM for API access. Most particularly this abstracts away persistence and makes creating and updating data on the server trivially simple. We're not going to do that here but we'll look at it more later.

If you're paying attention, you'll notice that the Route object contains the model data, but nothing at all seems to explicitly state the **template**. The location and name of the template are defined by conventions of name and structure of routes. In this case, the `app/routes/todo.js` route **must** be calling an `app/templates/todo.hbs` template. That's the convention. And of course, there we'll find it, so open it up.

T> There is an alternative structure called "pods", which makes the structure `app/todo/template.hbs` and `app/todo/route.js`, which for many people and in many cases is clearer. There's no "correct" approach, and they can be used interchangeably by simply generating with the `--pod` flag. For example, `ember g route todo --pod`.

# Working with templates

## Looping over the model

We can now edit the `app/templates/todo.hbs` and put in a loop over the model data we just added. Looping over model data is nice and easy. Ember (like Blade or any other template system) has systems for looping over data.

```
<h2>My Items</h2>

<ul>
{{#each model as |item|}}
  <li>{{item.text}}</li>
{{/each}}
</ul>

{{outlet}}
```

If the `|item|` is throwing you, this is a relatively new syntax apparently has something to do with maintaining object scope when passing data into components. It is the required syntax now.

Speaking of which, you should keep the `{{outlet}}` there too, at the bottom. We **will** be pulling content into this for nested subroutes.

If you go back to the browser and put in `http://localhost:4200/todo/` you'll again see that it does exactly what it should.

![Listing out all of the todo items](images/05-list-models.png)

## Adding some links

It's at about this point that the staggering ugliness of what we're working on is starting to bug us. We can fix that now, starting as ever with usability issues. No one is ever going to type in your correct route urls, so let's make some actual proper links. Obviously you could just write `<a href="todo">`, but you'd lose all your SPAness, and that wouldn't be good. Ember has a nice helper for that, the `link-to` helper.

We can provide a number of arguments to this thing, but the basic usage is a single argument to link to a route. If we edit the `apps/templates/application.hbs` file again we can put the following in and have a nice clean set of links for our application.

```
<ul>
  <li>{{#link-to 'index'}}Home{{/link-to}}</li>
  <li>{{#link-to 'about-us'}}About Us{{/link-to}}</li>
  <li>{{#link-to 'todo'}}ToDo List{{/link-to}}</li>
</ul>


{{outlet}}
```

![Now with added navigation menu](images/06-add-menu.png)

## Understanding outlets

Clicking between these is now handled as a transition inside the app. You'll note that the URL changes, but the interface doesn't really move around, as only the content of the `{{outlet}}` is changing. It's hard to really tell on such a simple site. This is now legitimately a single page app. It might not do much yet, but it really hasn't taken a lot of effort to make it go, either. Ember is dedicated to making Single Page Apps quick and easy to produce.

Back to our template, the outlet in Ember is very much like Laravel's `@yield` functionality, pulling in a sub-template. Unlike Laravel, which only needs to build the structure up once, Ember outlets are highly dynamic. They invariably have their contents changed on the fly. That's pretty much what they're for. Any template that is rendering a sub-template needs to have an outlet there to take that. To put it another way, every route needs an outlet to go into. Our `about-us` route (and anything else on that level) goes into the application template's outlet.

For now all of our routes are a flat structure. The only place they can or should render into is that one outlet. That will change very soon, which is why `todo.hbs` has an outlet in it.

# Making it look less awful

If you have functioning eyes you'll probably be moderately unhappy with the current aesthetic. We don't want to put too much effort into layout because it's out of scope of this book, but we want to get a nice clean look.

## Installing Bootstrap and Font Awesome

The simplest way to do this is to implement Bootstrap. Bootstrap is available as an Ember Add-on, which is a good way to learn how to use these. The process is simple thanks to EmberCLI: `ember install ember-bootstrap`.

Unlike a more typical NPM install, this will handle any NPM script installs and also Bower setup, add in any CSS or JavaScript files that are required by the addon, and update the build process. Just because I know we're going to use it anyway, let's throw some Font Awesome icons in there as well. Enter `ember install ember-font-awesome` and that one will do the same stuff.

T> Installing a new addon is one of the few things Ember server doesn't just build automatically. It doesn't have access to the new files that are added while it's running. Just kill it (control + c on Windows or Mac) and type `ember server` again (or just tap the up key to get the previous call) and it will come back up in under a second.

To show how easy these addons are to use, we'll just do some more setup to make things look better. Open up `apps/templates/application.hbs` and wrap all of the contents of that in a bootstrap container div.

```
<div class="container">
// everything that was already here
</div>
```

That's really all there is to it. The page will now have your title in a better font and with Bootstrap and Font Awesome ready to go, no gulpfile or build process. You don't even have to include the CSS or JavaScript, that's already done for you. How far you take the Bootstrap layout is entirely up to you, but we're going to go with very minimal layout here because otherwise the markup gets bulky.

One thing we will do is "fix" the nav with large slabs of Bootstrap boilerplate first to replace all our simple, semantic code.

```
<nav class="navbar navbar-default">
<ul class="nav navbar-nav">
  <li>{{#link-to 'index'}}Home{{/link-to}}</li>
  <li>{{#link-to 'about-us'}}About Us{{/link-to}}</li>
  <li>{{#link-to 'todo'}}ToDo List{{/link-to}}</li>
</ul>
</nav>
```

Now it looks and functions like a real Bootstrap nav. With one exception. If you click around, you'll notice that the link changes slightly, but not like a full active link in Bootstrap should be. There's a reason for this - Ember is adding a class to the currently active link, `class="active"`. But Bootstrap expects that code on the `li`, not the `a` tag. There are a bunch of solutions to this, most of which are kind of hacky. The cleanest and easiest is another addon. `ember install ember-cli-active-link-wrapper`.

Installing this lets you replace the `li`, **not the link-to** with an active-aware version.

```
{{#active-link}}{{#link-to 'index'}}Home{{/link-to}}{{/active-link}}
// and the other two
```

Click around and the problem is fixed. Nice and simple.

![A proper Bootstrap menu in place](images/07-menu-fixed.png)

# Nested routes

## How to show a single item

As well as showing a list, we want to be able to view, and more particularly edit, a single item. The best way to do this is to use nested routes. This means that our Todo route will have a number of options - notably `show`, `edit`, and `new`. Before we get started on that, we need to make sure the parent template, our todo template, is ready. If we open that up (`apps/templates/todo.hbs`) You can see our listing of each todo item. What we need to do is make sure there's an `{{outlet}}` somewhere on this template, or any sub-routes we generate will have nothing to render into. If you don't see one there it's because you replaced it before when adding the foreach loop. If you just pasted the foreach loop above the outlet you should be good to go, but either way, just make sure it's there. Accidentally removing an outlet is a common cause of confusion when nesting things.

## Generating a nested route and the Ember router

Generating a nested route is not really harder than generating any other. `ember g route todo/show --path=:id` will get the job done handily. This also sets the path option in the route directly from the command line, so that's already set in the router.

If you open the router file again at `app/router.js` you'll see the new route. All the generator work we've been doing has been also added into here automatically, so we haven't really needed to touch it. The todo route is obviously different to the others, now being the parent in a nested route. That means its second parameter is an anonymous function.

Inside that, the show route has a slightly different syntax as well, with an object on it containing the path. The `:id` in there is much the same as Laravel's `{id}`, but the first part of it is implied from the parent route, so the whole route is `todo/123` rather than just `123`. That object, and specifically the path part of it, is implied in all routes. For example, you could write our about route as `this.route('about-us', {path: 'about-us'});` if you wanted, but in the case of route paths that exactly match the route name it's implied. It's common for Ember to have these sensible defaults to make things more easy to read. You could, however, set a slightly different path and route name, such as 'about-us' and 'about'.

## More advanced link-to

Rather than typing this URL in to check it, we're going to link to it properly. Edit your `app/templates/todo.hbs` file, go to the loop, and add some links with the link-to helpers. The first argument is again the route. We can link-to a nested route using a dot syntax, in this case `todo.show`. The second argument to the link-to helper we haven't used yet. That lets us pass in the object we're transitioning to. This automatically sets a model for the new route. We'll add some Bootstrap markup at the same time.

```
<div class="row">
  <div class="col-sm-4">
    <ul class="list-group">
    {{#each model as |item|}}
      <li class="list-group-item">
        {{#link-to 'todo.show' item}}
          {{item.text}}
        {{/link-to}}
      </li>
    {{/each}}
    </ul>
  </div>
  <div class="col-sm-8">
    {{outlet}}
  </div>
</div>
```


## The template for a single item

We have a template now as part of this generation, and it should be at `app/todo/show.hbs`. All we really need is some basic layout in this and we'll be good to go. Note that the model for a single todo will be a todo item, rather than the collection we used in the parent route. That's what we passed in at the end of the link-to.

```
<!-- app/todo/show.hbs -->
<h3>Show Item</h3>

<div class="form-group">
  <label>Text:</label>
  <p class="form-control-static">{{model.text}}</p>
</div>
<div class="form-group">
  <label>Status:</label>
  <p class="form-control-static">{{model.checked}}</p>
</div>
```

Now you can go to the application, and click through to the Todo page, then click on any of the individual items to view its details.

!["Show Item" heading missing from this screenshot](images/08-single-route.png)

## Debugging with the Ember Inspector

This seems to be working now, but there's a bug in it. If you refresh the page, you'll see our todo item's text field gets wiped. Each URL should work on its own merits. It's a URL and a perfectly valid one, so this isn't the behaviour we want. I suggested earlier that you install the Ember Inspector extension for whatever browser you use, and am now going to assume you did so. We can use Ember Inspector to give us a bit more of an idea of what's happening with this code.

Open your browser debug toolbar with F12 and you'll see a tab for Ember. For the most part that doesn't do anything, but when browsing an Ember app it starts to pop in a bunch of details for us.

To get a better idea of our issue here, we need to go to the View Tree tab.

This shows the structure of our application and what data it contains. If you click on the first item in our list, and then look down at the Name column where it says `todo.show` you'll see the Model shows a useful object with our text, checked status, etc. However, if you refresh that individual item, and you'll see the model changes to only include an id. And even that is just coming from the URL.

![The structure of an Ember app - note the empty model object](images/09-ember-inspector.png)

This pretty much sums up the problem. This route has no actual model.

We were masking that issue when we navigated through the interface, beause we passed an item from the Todo collection to serve as the model. However, when stripped of the access to the todo parent route, the lack of model on todo/show becomes a problem. Thankfully it's a problem that's easy to fix.

We **could** just dump in the same JavaScript array as the parent route, search it and return the correct object. But what we really want to do is get that array directly from the parent. Thankfully, Ember provides a nice simple way to do that.

Note that in this case we need to pass the parameters into the model hook. That wasn't necessary in the listing, because it didn't take any parameters. That parameter object is made automatically by Ember and provided here for you as the first argument.

```~
// app/todo/show.js
export default Ember.Route.extend({
  model(params){
    let items = this.modelFor('todo');
    return items.find(function(item){
      return +params.id === item.id;
    });
  }
});

// alternatively shorter form ES6
return this.modelFor('todo')
  .find(item => +params.id === item.id);
```~

If the `+params.id` part is confusing, it's an unusual but standard syntax. This isn't Ember, it's just a JavaScript unary operator.

T> If you look at the docs for link-to you'll see that it shows the third option as the id, which would make you think you pass in todo.id instead of the whole todo object. Either will work, but they work slightly differently. Passing in the id makes the show route run its own model hook, whereas passing in the object overrides it. In this app it's not noticeably different, but in many larger applications that `todo.show` route's model hook will run an API request. This would make passing in the model significantly faster and cleaner.

![Note the correct objects in the Model](images/10-ember-inspector-fixed.png)

# Editing

We're going to start off by editing our existing items. It doesn't involve us managing the addition or removal of records, which we'll deal with separately.

## Another nested route - edit

What we need is another route, for a editing a todo item. `ember generate route todo/edit --path=:id/edit`.

If we have another look at our router after doing that we'll notice that the new route is **not** nested inside the show route, even though it might look like it from the URL. The path and the nesting absolutely do not have to be identical. How you structure the nesting should be based not on relationships between the **data**, but on relationships within the **interface**. The show and edit route are siblings, and from an interface point of view we want the edit form to replace display, not sit inside it.

This is a key for Ember that took me a while to really **get**. You should be thinking of all of this as the structure required for your interface - not the structure you require for your data. If the interface is nested, nest the routes. If they're not... don't. The relationship between data types, etc, is irrelevant. It's the relationship between the interface elements that really matters.

The `edit` route needs another model hook, which is the exact same code as the `show` model hook, so just grab that and paste it into the routes file, which in this case is located at `app/routes/todo/edit.js`.

## The input helper

Much like links, inputs are an important part of an Ember app, as they are where user changes happen. As such, they have a special helper. As well as the obvious properties, such as `class`, the input helper critically takes a value property. That value is the model property being edited or created. The `app/templates/todo/edit.hbs` file should look very much like the following.

```
<!-- app/todo/edit.hbs -->
<h3>Update Item</h3>

<div class="form-group">
  <label for="text">Text</label>
  {{input value=model.text class="form-control"}}
</div>
<div class="form-group">
  <button class="btn btn-info"{{action "updateItem" model}}>
    {{fa-icon "cloud-upload"}} Update
  </button>
</div>
```

Again, we'll update the todo loop to provide a link to this new edit route, as well as add some Bootstrap and Font Awesome magic to the interface. The `{{action "updateItem" model}}` part of this is an action helper, telling Ember to run the update function on click (the default), and passing in the model at that time.

```
<ul class="list-group">
{{#each model as |item|}}
  <li class="list-group-item">
  {{#link-to 'todo.show' item}}{{item.text}}{{/link-to}}
  {{#link-to 'todo.edit' item}}
    {{fa-icon "pencil" class="pull-right edit-link"}}
  {{/link-to}}
  </li>
{{/each}}
</ul>
```

T> Note the simplicity of the implementation of Font Awesome, thanks to the add-on we installed earlier.

![The edit route when active](images/11-edit-route.png)

If you edit the details, you'll notice that as you change the details in the field, you also directly change the actual list-item. This is something called "Two-way binding". Two-way binding is a mixed blessing that looks great in a demo, but can cause state conflicts in a larger application. We'll deal with that in a larger application. You'll also notice that when you hit the "Update" button things go very badly wrong. The error says that there is nothing to handle the "updateItem" action, and this is entirely accurate.

## Actions

Actions in Ember can be handled on a controller (as mentioned before) but in this case we'll handle it on the route, the todo/edit route, specifically. Step one is obviously making that route.

If you open that file at `app/routes/todo/edit.js` you'll see a new route file, roughly the same as our default route, or really anything newly generated in Ember. We need to add an actions object to that route, containing an update function.

```
//app/routes/todo/edit.js
export default Ember.Route.extend({
  model() {
    return this.modelFor('todo')
      .find(item => +params.id === item.id);
  },
  actions: {
    update(item){
      alert(item.text + ' saved');
    }
  }
});
```

## How actions work in Ember

Actions in Ember aren't always easy to follow, so we'll stop here for a moment and talk about how they work. The use of the action helper - `{{action 'actionName'}}` binds that element to an event. By default this is a click, and so you don't need to explicitly say that. When the event is triggered, Ember looks around for an action to run. It "bubbles" the event up through the application. The first place it checks is the controller. If it doesn't find an event there it will check the current route. If it doesn't find one **there** it will check the parent route. And then the parent route of that, if applicable. Eventually it will hit the application route, check that for the action, and if it doesn't find it there will sit down and have a cry. You'll see that in the console and then realise that `updote` is not what you meant to write.

T> As well as the format `{{action 'actionName'}}` you can also use something called *Closure Actions*. These are particularly good for components, and we'll refactor to use them later.

You'll hopefully have noticed that parameter in our action function, the item parameter. That's being passed through in the action helper in the template up above, and contains the model initially provided by the route. All of the actual changes to the object have been done in the model by editing it in the form, so in this case there's nothing to actually save. The model has already changed. In a real application this would be where those changes were persisted, saving the data back to the API, etc.

# Testing in Ember

We want to change direction now. We've just been ripping through this and adding functionality. This is great, but it misses some of the key benefits in Ember. We want to be able to make complex functionality that's tested and maintainable. In a small app like this is probably doesn't matter, but in something large in production there's little that matters more.

## How to run your tests

The simplest way to run your tests is to go to `http://localhost:4200/tests`. This will show a page with all of your tests on it. There are two possibilities at this point. If you've been largely ignoring me, and doing things at your own pace or however you want, everything will be fine, all tests green. If you actually listened and followed the instructions to the letter you have at least one major error you need to fix. There's a life lesson in there.

![The Ember test page](images/12-test-page.png)

The error is pretty simple. When we generated the routes earlier, EmberCLI also generated test stubs along with them. The tests that get stubbed are trivial, they just tests that the JavaScript is valid and exists, that there are no lint errors. However, if you recall from earlier, we actually deleted the `about-us` route. It no longer exists. We can get rid of that error by simply deleting the `tests/unit/routes/about-us.js` file. There's no point testing code that doesn't exist. With that file gone, it **should** just test green.

This is the easiest way to test, but it's not the best. The best is to use EmberCLI. We can run the tests by simply running the command `ember test`. There's a fair chance that will get an error. It will say something along the lines of "Unable to find PhantomJS". Phantom is a "headless browser". It lets JavaScript execute in a command line, with no interface or display, and shows the results of the page tests, all run in memory. It's not exactly a default install. On a Mac at least it's easy to set up. `brew install phantomjs`

With that in place, `ember test` should happily display successful output.

![The output of a successful "ember test" command](images/13-testing-pass.png)

## How to write tests

For the most part, Ember will generate the tests for you, or at least a test stub. This is a good starting point and saves you from having to do too much work. You also get the benefit that the intial tests in the stub are jslint tests, so if you violate any important JavaScript style rules it will get picked up. The `ember server` process is actually doing the same thing, constantly judging your code, and you can see style errors output there too.

Our application is relatively simple, and most of it is default framework behaviour, which we don't need to test ourselves. There is little complex calculation that could be helped with a unit test. What we actually want to test is our functionality. That when you save, things get added, that kind of thing. We can do that with acceptance tests.

## Acceptance testing

Acceptance testing is a sort of automated test specifically about whether the application meets the specifications or requirements. It is fairly typical for an acceptance test to check and confirm the acceptance criteria of the business or client.

They don't test **how** it works, just run through the interface and confirm the expected behaviour. Note that this is **behaviour**. We shouldn't be excessively testing display of elements except where user activity is changing it.

Unlike unit tests, which intend to test tiny pieces of the site in great detail while isolated, acceptance tests are for broad, actual user-style functionality. An acceptance test might check, for example, that a user can log in, or that a signup form works, or that a product can be added to the cart, and then checkout completed.

## Creating an acceptance test

The format should come as no surprise. `ember g acceptance-test about-us` will generate a file at `tests/acceptance/about-us-test.js`. Note that this is not in `app/`. The tests are not part of your app.

There is one placeholder test in place that just says `test('visiting /about-us', function...`. The test is then very readable, close to normal language. The vast majority of acceptance tests follow a consistent pattern: visit a page - do a thing - check the result. You can see our test here doing approximately that, though it doesn't have much to do. It visits a page, and then just confirms that you're actually on the page it thinks it's on.

We can add a second test here, just to confirm that the title is what you think.

```
test('heading for /about-us page', function(assert) {
  const expectedHeading = 'About Us';
  visit('/about-us');

  andThen(function() {
    let actualHeading = find('h2').text().trim();
    assert.equal(expectedHeading, actualHeading);
  });
});
```

A trivial test, but it shows the pattern. We'll go a bit more into detail about what this is actually doing very soon. If you run `ember test` you'll see that test as an addition to our previous suite of tests.

Since we're creating some new functionality, let's do this in a Behaviour Driven Development (BDD) approach. This means we write the tests **first**, even before we have working code. We want to create a new Todo item in the interface. BDD gives us an opportunity to think through what it will take to decide when that "works".

```
ember g acceptance-test new-item
```

Opening up `tests/acceptance/new-item-test.js` will show you the same boilerplate as for about. This is a lot less useful, though. There isn't a valid route at `/new-item`.

What we're going to want to do is pretty simple: Go to the todo list page. Click "Add Item" button, fill in the form, click "Create" button. Confirm the form closed and that the item has been added to the list.

Ignoring most of the wrapper, the bit we care about is the part starting from `visit()`.

```
visit('/todo');
click('#new-item-button');
fillIn('#new-item-text', 'Some random text');
click('#create-item-button');
```

That basically covers the interactions a user would have. We want to go to the todo items page, click on the element with the given id, fill in an input with that specific id with given info, and then click the submit button.

There is a principle in testing, often phrased as **Arrange, Act, Assert**. You set up your data or state, then do the "thing", then check it. In this case there's little to arrange, but many acceptance tests would have quite a lot of setup. For example, they might create a test customer, or mock data. In this case, we've covered all the act, all the things we need to do to confirm. Now we need the assert, which is all of the lines wrapped in `andThen`.

If you're wondering why the `andThen` instead of just following a logical chain, the `andThen`  provides security around potentially asynchronous calls and actions. It will only run these when everything is clear and ready.

```
andThen(function() {
    assert.equal(/*we haven't really thought this through*/);
});
```

So how do we confirm this stuff? There are a few things we need to verify. The main one is that the new item actually got created. The simplest way to check that is to see how long the list was before and after. It will also be the last item, and we also want to check that its text matches the provided string. We also want to make sure that saving redirects us to the show page. So let's do some refactoring and put it all together.

```
test('Creating a new todo item', function(assert) {

  const itemText = 'Some random text';
  const expectedLength = 5;

  visit('/todo');
  click('#new-item-button');
  fillIn('#new-item-text', itemText);
  click('#create-item-button');

  andThen(function() {
    let itemList = find('.list-group-item');
    let itemListLength = itemList.length;

    let lastItemText = itemList.last().text().trim();
    assert.equal(expectedLength, itemListLength);
    assert.equal(itemText, lastItemText);
    assert.equal(currentURL(), '/todo/'+ itemListLength);
  });
});
```

There's a lot to unpack here, but most of it isn't as mysterious as it looks. In fact, probably the most complex thing here is `find()`. All that does is wrap around jquery's excellent `$()` selector voodoo. As a result things like `.length` and `.text()` are simply well known jquery (or js) functionality. This also means that `find()` is vastly more flexible than it has any right to be, allowing crazy jquery selectors like `div.user-list:visible` or `input[value="Buy Pizza"]`.

T> If you're thinking that littering your tests with selectors is a bad practise you're dead on. A better approach to this is to use page objects, specifically by installing `ember-cli-page-objects`. This lets you define the interface of a page up front, and interact with it much more cleanly, such as `searchPage.visit().keyword('cactus').submit()` and asserting on `homePage.title`. You can also wrap logical groups of actions, like "createNewPost" to fill in multiple field. It is highly recommended to do this if doing a large amount of acceptance testing.

When you run this test you'll notice something else. It fails. This is the plan. This is the point of this kind of testing. Write a failing test first, then make it not fail. When it doesn't fail, the feature is working. This is Behaviour Driven Development.

# Creating a new item

The new item is slightly more complex because it affects the collection as well as requiring the generation of a new object. It's not much more so, and certainly starts off the same.

## As always - generate another route

```
ember generate route todo/new
```

The route is
We can grab the exact same form details, copying the entire of `edit.hbs` and pasting it into `new.hbs`, then just changing the word "Update" where it appears to "Create". Don't forget to change the action! That will be `create`, this time course.

Before we forget, we need to add a button to create a new item, and we need to put it into `app/templates/todo.hbs`. Under the list you can just put the following line to get a nicely styled button.

```
{{#link-to 'todo.new' class="btn btn-info"}}
  {{fa-icon "plus-circle"}} Add item
{{/link-to}}
```

The content of the new route is slightly less obvious than some of the others. It might not be initially obvious that we actually need a model. After all, this route is about **making** a model. But creating an empty model up front gives us something to edit. In fact we need a model backing the new template in order to give the template something to hook into, so that when the form is being edited it's making changes to *something*.

In theory what we need to return from the model hook is a blank Ember Object. In practise, Ember will wrap anything returned from the model hook in its own voodoo, so we literally just need to return an empty javascript object.

The `routes/todo/new.js` file will contain:

```
export default Ember.Route.extend({
  model(){
    return {};
  }
});
```

We will also need an action.

```
export default Ember.Route.extend({
  model(){
    return {};
  },
  actions: {
    createItem(item){

      let collection = this.modelFor('todo');
      let newObject = {
        id: collection.length+1,
        text: item.text,
        checked: false
      };
      collection.pushObject(newObject);
      this.transitionTo('todo.show', newObject);
    }
  }
});
```

A lot of that should be easy to follow. The actions object contains a single create function, which is passed the previously mentioned now-not-so-empty model. Inside that is where newer things are happening.

The collection of all the different todo items is the model for the todo route, so we grab that. It's simply the easiest thing to do, and to be honest it most clearly reflects the intent here. This is an Ember Collection object, so we use the `pushObject` method to add a new item to it. It seems like we could just use the standard array push, but pushObject respects all the watchers and magic of Ember, making it immediately just as usable as any other item in our collection. Again, it would be typical to persist this new item back to the server as well, but a step not being taken by our demo application. Then we just redirect to the page for that item.

For the most part, the template here will be the same as the edit template, so grab that from `app/templates/todo/edit.hbs` and copy it to `app/templates/todo/new.hbs`. We'll need to make some changes for it to match the test. You need to add an id to elements, the new item button on the todo.hbs needs the id of "new-item-button" as given in the text, the input given "new-item-text", and the new.hbs button the id of "create-item-button".

![Our list now has an add button](images/14-listing-with-add.png)

If we run our `ember test` command again we will notice that the test now successfully passes. Congratulations, you are now an expert at  **BDD** and can put it on your resume.

# Checking an item

There's only one real requirement left. A todo list that can't check off items is in poor shape. We need to add that functionality. The first step is to figure out whose responsibility this is. It might be initially tempting to assume this is the responsibility of the edit route, but remember, from an interface point of view we really just want to handle this directly in the todos listing view, not go somewhere else to do it.

## Creating the tests

Again, we're going to BDD this, so let's start with `ember g acceptance-test todo-check`.

And again, this is going to need some thinking through. What we want to do is click the **second** checkbox, and then confirm that the item is crossed out. This should be enough to confirm that our behaviour is as expected.

```
test('Checking a new todo item', function(assert) {
  visit('/todo');
  click('.list-group-item:nth-child(2) .check-icon');

  andThen(function() {
    let row = find('li:nth-child(2)');
    let rowIsChecked = row.hasClass('checked');
    assert.ok(rowIsChecked);
  });
});
```

If you run your `ember test` command again you'll find this doesn't pass, and for obvious reasons. We haven't done anything to this code that would make it work.

## A simple action

This action is surprisingly small. All we really want to do is toggle on and off a particular property on a given item that's passed into the action. To do this we just need to add the action object with this function to the todo route.

~~~~~~~
//app/routes/todo.js
export default Ember.Route.extend({
  model(){
		return [
			{id: 1, checked: false, text: 'Buy milk'},
			{id: 2, checked: false, text: 'Buy bread'},
			{id: 3, checked: false, text: 'Bring back Firefly'},
			{id: 4, checked: false, text: 'Conquer planet'}
		];
	},
    actions: {
      checkItem(item){
        Ember.set(item, 'checked', !Ember.get(item, 'checked'));
      }
    }
  }
});
~~~~~~~

This takes in the item, and then uses `.set` to update a property - checked, in this case. Using Ember.set instead of something like `item.checked = true` allows the change to propagate all through the app, keeping everything properly in sync. If you try and just set the property directly Ember Inspector will spit up warnings at you. The `.get` plays a similar role, returning a safe version of the value of the property on that object, and the ! just causes it to invert. Again, this would be the point where we could be saving back to an API.

## Connecting up the action in the template

The only other thing to do is add a checkbox with the action and a bit of styling on the list item. We'll start by modifying the todo list template again. This is now our complete todo.hbs, including some Bootstrap layout and all the additional buttons and classes.

~~~~~~~
<!-- app/tempates/todo.hbs -->
<h2>Current Items</h2>

<div class="row">
<div class="col-md-4">
<ul class="list-group">
{{#each model as |item|}}
  <li class="list-group-item
    {{if item.checked "checked" "unchecked"}}">
    <span class="check-icon" {{action 'checkItem' item}}>
      {{fa-icon (if item.checked "check-square-o" "square-o")}}
    </span>

    {{#link-to 'todo.show' item}}{{item.text}}{{/link-to}}
    {{#link-to 'todo.edit' item}}
      {{fa-icon "pencil" class="pull-right edit-link"}}
    {{/link-to}}
  </li>
{{/each}}
</ul>
  {{#link-to 'todo.new' class="btn btn-info"}}
    {{fa-icon "plus-circle"}} Add item
  {{/link-to}}
</div>
<div class="col-md-4">
  {{outlet}}
</div>
</div>
~~~~~~~

![Checkbox now in place](images/15-listing-with-checkbox.png)

The new code is mostly in the span that we've thrown an action on and put an icon inside. A conditional `if` as the second parameter tells it whether to have the icon checked or unchecked. Similar code exists above and tells the class whether to be checked or unchecked so our styling will work.

If we run `ember test` we get the confirmation that we've met our requirement.

## Handling CSS

Styling isn't something we've looked into yet, so now is the time. Open up `app/styles/app.css` and you'll have an empty stylesheet to work with. Adding any styling into there will be immediately built and put into the app.css used by the application. We're going to dump in some css mostly just for look. What exactly it does should be readily apparent.

```
.check-icon {
  display: inline-block;
  width: 15px;
}

li.checked {
  text-decoration: line-through;
}

li .edit-link {
  display: none;
}

li:hover .edit-link {
  display: inline-block;
}
```

Most of it is just polish so that we don't see the edit icons unless we mouseover the list item, and the second rule is to make checked items have a strikethrough effect.

![A finished app, for now](images/16-listing-with-styles.png)

This doesn't just have to be CSS. If you're wanting to use Sass, and you should, it's trivial to set up. Just install `ember install ember-cli-sass` and you can just rename `app/styles/app.css` to `app/styles/app.scss`, or create a new one.

That's it. We're done. We've built an Ember app. With the knowledge of how to do it and given a reasonable expectation of the details of the layout, this whole thing could be done in about 20 minutes. Sure, it doesn't do a whole lot. But it does let you see clearly that Ember does **not** have to be hard. It's got a quite clear structure, and is highly capable without having to worry about how to set things up.

Still, there's a lot we've done a bit poorly, and definitely some functionality we could add, such as saving. Stick around and we'll go through that now.